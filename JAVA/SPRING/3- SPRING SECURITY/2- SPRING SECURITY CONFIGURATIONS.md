## 1. Spring Security Project

A **Spring Security project** is typically a **Spring Boot application** where:

- Security is applied using filters
    
- Authentication and authorization are centralized
    
- Configuration is declarative
    

### Real-World Usage

- Admin dashboards
    
- Public websites
    
- Internal enterprise systems
    
- APIs (JWT-based)
    

---

## 2. Spring Security Dependencies

### Required Dependency

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-security</artifactId>
</dependency>
```

### What This Enables Automatically

- SecurityFilterChain
    
- Default login page
    
- Default user (generated password)
    
- CSRF protection
    

---

## 3. Spring Security Configuration (Modern Approach)

Spring Security is configured using **beans**, not inheritance.

```java
@Configuration
@EnableWebSecurity
public class SecurityConfig {
}
```

> `WebSecurityConfigurerAdapter` is deprecated.

---

## 4. PasswordEncoder Bean

### Why It’s Mandatory

Passwords must **never** be stored or compared as plain text.

### Recommended Encoder

```java
@Bean
public PasswordEncoder passwordEncoder() {
    return new BCryptPasswordEncoder();
}
```

### Interview Tip

If you don’t define this bean → authentication fails.

---

## 5. InMemoryUserDetailsManager Bean

### Purpose

Stores users **in memory**.

### When to Use

- Learning
    
- Demos
    
- Tests
    

❌ Not for production

---

## 6. SecurityFilterChain Bean (Core Configuration)

This bean defines **everything**:

- CSRF
    
- Authorization
    
- Login
    
- Logout
    

```java
@Bean
public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
    http
        .authorizeHttpRequests(auth -> auth
            .anyRequest().authenticated()
        )
        .formLogin()
        .logout();
    return http.build();
}
```

---

## 7. CSRF (Cross-Site Request Forgery)

### What CSRF Is

An attack where a logged-in user is tricked into sending a request.

### When CSRF Is Enabled

- Session-based applications (default)
    

### When to Disable CSRF

- Stateless REST APIs
    
- JWT-based APIs
    

```java
http.csrf(csrf -> csrf.disable());
```

### Interview Rule

> Disable CSRF **only** when sessions are not used.

---

## 8. Authorization Rules Explained

### authorizeHttpRequests

Entry point for defining authorization rules.

```java
.authorizeHttpRequests(auth -> auth ...)
```

---

### requestMatchers

Matches URL patterns.

```java
.requestMatchers("/login", "/public/**")
```

---

### permitAll()

Allows access **to everyone**.

```java
.requestMatchers("/css/**").permitAll()
```

---

### anonymous()

Allows access **only to unauthenticated users**.

```java
.requestMatchers("/login").anonymous()
```

---

### authenticated()

Requires the user to be logged in.

```java
.anyRequest().authenticated()
```

---

### hasRole()

Restricts access based on role.

```java
.requestMatchers("/admin/**").hasRole("ADMIN")
```

---

## 9. permitAll vs anonymous (Important)

|Feature|permitAll|anonymous|
|---|---|---|
|Logged-in users|Allowed|❌ Blocked|
|Non-logged users|Allowed|Allowed|
|Use case|Public pages|Login/register pages|

---

## 10. Login with Default Login Form

### Behavior

- Auto-generated by Spring Security
    
- Appears when `formLogin()` is enabled
    

### Use Case

- Internal tools
    
- Prototypes
    

---

## 11. Login with Custom Login Form

### Why Use It

- Branding
    
- UX control
    
- Custom errors
    

### Configuration

```java
.formLogin(form -> form
    .loginPage("/login")
    .loginProcessingUrl("/login")
    .defaultSuccessUrl("/home")
)
```

### Important Rule

Form fields must be:

- `username`
    
- `password`
    

---

## 12. AuthenticationFailureHandler

### Purpose

Custom logic when login fails.

### Real-World Use

- Show messages
    
- Log attempts
    
- Security alerts
    

---

## 13. LogoutSuccessHandler

### Purpose

Custom logic after logout.

### Real-World Use

- Cleanup
    
- Redirects
    
- Auditing
    

---

# 14. FULL Real-World Example (Everything Together)

### Scenario

A **Spring Boot web application** with:

- Custom login page
    
- Role-based access
    
- CSRF disabled (API-style)
    
- In-memory users (demo)
    
- All authorization keywords used
    

---

## 14.1 Security Configuration
# One Complete `SecurityFilterChain` Example (Everything in One Place)

```java
@Configuration
@EnableWebSecurity
public class SecurityConfig {

    /*
     * ============================
     * Password Encoder
     * ============================
     * Used to hash and verify passwords securely.
     */
    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }

    /*
     * ============================
     * In-Memory Users (DEMO ONLY)
     * ============================
     */
    @Bean
    public UserDetailsService userDetailsService(PasswordEncoder encoder) {

        UserDetails user = User.builder()
            .username("user")
            .password(encoder.encode("1234"))
            .roles("USER")
            .build();

        UserDetails admin = User.builder()
            .username("admin")
            .password(encoder.encode("admin"))
            .roles("ADMIN")
            .build();

        return new InMemoryUserDetailsManager(user, admin);
    }

    /*
     * ============================
     * Authentication Failure Handler
     * ============================
     * Handles different login failure cases.
     */
    @Bean
    public AuthenticationFailureHandler authenticationFailureHandler() {
        return (request, response, exception) -> {

            if (exception instanceof BadCredentialsException) {
                response.sendRedirect("/login?error=bad_credentials");
            } else if (exception instanceof LockedException) {
                response.sendRedirect("/login?error=account_locked");
            } else if (exception instanceof DisabledException) {
                response.sendRedirect("/login?error=account_disabled");
            } else {
                response.sendRedirect("/login?error=unknown");
            }
        };
    }

    /*
     * ============================
     * Logout Success Handler
     * ============================
     * Executed after successful logout.
     */
    @Bean
    public LogoutSuccessHandler logoutSuccessHandler() {
        return (request, response, authentication) -> {
            response.sendRedirect("/goodbye");
        };
    }

    /*
     * ============================
     * Main Security Filter Chain
     * ============================
     */
    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {

        http

            /*
             * ============================
             * CSRF
             * ============================
             * Disabled for APIs or demo purposes.
             * ENABLE it for session-based apps.
             */
            .csrf(csrf -> csrf.disable())

            /*
             * ============================
             * CORS
             * ============================
             * Needed for frontend apps (React/Angular).
             */
            .cors(Customizer.withDefaults())

            /*
             * ============================
             * Authorization Rules
             * ============================
             */
            .authorizeHttpRequests(auth -> auth

                // Static resources - public
                .requestMatchers("/css/**", "/js/**").permitAll()

                // Login & register only for unauthenticated users
                .requestMatchers("/login", "/register").anonymous()

                // Admin endpoints require ADMIN role
                .requestMatchers("/admin/**").hasRole("ADMIN")

                // All other requests require authentication
                .anyRequest().authenticated()
            )

            /*
             * ============================
             * Form Login (Custom Login Page)
             * ============================
             */
            .formLogin(form -> form
                .loginPage("/login")
                .loginProcessingUrl("/login")
                .defaultSuccessUrl("/home", true)
                .failureHandler(authenticationFailureHandler())
                .permitAll()
            )

            /*
             * ============================
             * Logout Configuration
             * ============================
             */
            .logout(logout -> logout
                .logoutUrl("/logout")
                .logoutSuccessHandler(logoutSuccessHandler())
                .invalidateHttpSession(true)
                .clearAuthentication(true)
                .deleteCookies("JSESSIONID", "remember-me")
            )

            /*
             * ============================
             * Exception Handling
             * ============================
             */
            .exceptionHandling(ex -> ex

                // 401 - Not authenticated
                .authenticationEntryPoint((req, res, e) ->
                    res.sendError(HttpServletResponse.SC_UNAUTHORIZED)
                )

                // 403 - Authenticated but forbidden
                .accessDeniedHandler((req, res, e) ->
                    res.sendError(HttpServletResponse.SC_FORBIDDEN)
                )
            )

            /*
             * ============================
             * Session Management
             * ============================
             */
            .sessionManagement(session -> session
                .sessionCreationPolicy(SessionCreationPolicy.IF_REQUIRED)
                .maximumSessions(1)
                .maxSessionsPreventsLogin(true)
            )

            /*
             * ============================
             * Remember-Me Authentication
             * ============================
             */
            .rememberMe(remember -> remember
                .tokenValiditySeconds(86400)
                .key("verySecretKey")
            )

            /*
             * ============================
             * Security Headers
             * ============================
             */
            .headers(headers -> headers
                .frameOptions().sameOrigin()
                .xssProtection()
                .contentTypeOptions()
            );

        return http.build();
    }
}
```

---

## How to Read This Code (Exam / Interview Tip)

Read it **top to bottom** as a request lifecycle:

1. CSRF & CORS
    
2. Authorization rules
    
3. Authentication mechanism
    
4. Login behavior
    
5. Logout behavior
    
6. Exception handling
    
7. Session handling
    
8. Cookies & headers
    
---
## Interview One-Liner (Gold)

> A `SecurityFilterChain` defines authentication, authorization, session handling, exception handling, and request security in a single declarative configuration.
---

## 15. End-to-End Request Flow

1. User visits `/admin/dashboard`
    
2. Not authenticated → redirected to `/login`
    
3. User logs in
    
4. Role checked using `hasRole`
    
5. Access granted or denied
    
6. Logout clears authentication
    

---

## 16. Interview Checklist (Memorize)

- Security is filter-based
    
- `SecurityFilterChain` is mandatory
    
- CSRF disabled for stateless apps
    
- `authorizeHttpRequests` defines access rules
    
- `requestMatchers` match URLs
    
- `hasRole` enforces roles
    
- `anonymous` blocks logged-in users
    
- `permitAll` allows everyone
    
- `authenticated` requires login
    

---

## 17. Real Project Mapping

|Project Type|Setup|
|---|---|
|Learning|InMemory + form login|
|Admin panel|Custom login|
|Public site|permitAll pages|
|REST API|JWT + CSRF disabled|
